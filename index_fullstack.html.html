<!-- 
  OCT è§†ç½‘è†œå›¾åƒæ™ºèƒ½è¯Šæ–­ç³»ç»Ÿ
  åŠŸèƒ½ï¼š
  1. åŠ è½½ TensorFlow.js æ¨¡å‹è¿›è¡Œ OCT å›¾åƒåˆ†ç±»
  2. ç”Ÿæˆ Occlusion Sensitivity çƒ­åŠ›å›¾ä»¥è§£é‡Šæ¨¡å‹å†³ç­–
  3. æä¾›äº¤äº’å¼ UI è°ƒæ•´çƒ­åŠ›å›¾å‚æ•°
-->
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OCT è§†ç½‘è†œæ™ºèƒ½è¯Šæ–­ç³»ç»Ÿ (TensorFlow.js)</title>
    <!-- å¼•å…¥ TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>
    <style>
        :root {
            --bg-color: #121212;
            --card-bg: #1e1e1e;
            --text-primary: #e0e0e0;
            --text-secondary: #a0a0a0;
            --accent-color: #00bcd4;
            --accent-hover: #00acc1;
            --border-color: #333;
            --success-color: #4caf50;
            --warning-color: #ff9800;
            --danger-color: #f44336;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-primary);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        header {
            background-color: var(--card-bg);
            padding: 1rem 2rem;
            border-bottom: 1px solid var(--border-color);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h1 { margin: 0; font-size: 1.5rem; color: var(--accent-color); }
        .status { font-size: 0.9rem; color: var(--text-secondary); }
        .status.ready { color: var(--success-color); }

        main {
            flex: 1;
            padding: 2rem;
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
            box-sizing: border-box;
            transition: all 0.3s ease;
        }

        /* ä¸Šä¼ åŒºåŸŸ */
        .upload-container {
            border: 2px dashed var(--border-color);
            border-radius: 12px;
            padding: 4rem 2rem;
            text-align: center;
            background-color: var(--card-bg);
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 2rem;
        }

        .upload-container:hover, .upload-container.drag-over {
            border-color: var(--accent-color);
            background-color: rgba(0, 188, 212, 0.05);
        }

        .upload-icon { font-size: 3rem; margin-bottom: 1rem; color: var(--text-secondary); }
        .upload-text { font-size: 1.2rem; color: var(--text-primary); margin-bottom: 0.5rem; }
        .upload-subtext { font-size: 0.9rem; color: var(--text-secondary); }
        
        #file-input { display: none; }

        /* ç»“æœç½‘æ ¼å¸ƒå±€ */
        .results-grid {
            display: none; /* åˆå§‹éšè— */
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto auto;
            gap: 1.5rem;
            height: 100%;
        }

        .card {
            background-color: var(--card-bg);
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border: 1px solid var(--border-color);
        }

        h2 { margin-top: 0; margin-bottom: 1rem; font-size: 1.1rem; border-bottom: 1px solid var(--border-color); padding-bottom: 0.5rem; color: var(--accent-color); }

        /* å›¾åƒå±•ç¤ºåŒº (å·¦ä¸Š) */
        .image-view-card {
            grid-column: 1 / 2;
            grid-row: 1 / 2;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            min-height: 300px;
            justify-content: center;
        }

        .image-wrapper {
            position: relative;
            display: inline-block;
            max-width: 100%;
        }

        #preview-image {
            max-width: 100%;
            max-height: 400px;
            display: block;
            border-radius: 4px;
        }

        #heatmap-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* å…è®¸ç‚¹å‡»ç©¿é€ */
            border-radius: 4px;
        }

        /* æ¦‚ç‡å±•ç¤ºåŒº (å·¦ä¸‹) */
        .prob-card {
            grid-column: 1 / 2;
            grid-row: 2 / 3;
        }

        .prob-bar-container {
            margin-bottom: 0.8rem;
        }

        .prob-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.2rem;
            font-size: 0.9rem;
        }

        .prob-bar-bg {
            height: 8px;
            background-color: #333;
            border-radius: 4px;
            overflow: hidden;
        }

        .prob-bar-fill {
            height: 100%;
            background-color: var(--accent-color);
            width: 0%;
            transition: width 0.5s ease-out;
        }

        /* çƒ­åŠ›å›¾æ§åˆ¶åŒº (å³ä¸Š) */
        .heatmap-controls-card {
            grid-column: 2 / 3;
            grid-row: 1 / 2;
            display: flex;
            flex-direction: column;
        }

        .heatmap-legend-container {
            display: flex;
            align-items: center;
            margin-bottom: 1rem;
            padding: 0.5rem;
            background: rgba(0,0,0,0.2);
            border-radius: 6px;
        }
        
        .heatmap-legend-gradient {
            width: 20px;
            height: 100px;
            background: linear-gradient(to bottom, red, yellow, transparent);
            margin-right: 10px;
            border-radius: 2px;
        }

        .heatmap-legend-labels {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            height: 100px;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .control-group { margin-bottom: 1rem; }
        .control-group label { display: block; margin-bottom: 0.3rem; font-size: 0.9rem; }
        .control-group input[type="range"] { width: 100%; cursor: pointer; }
        .control-value { float: right; color: var(--accent-color); font-family: monospace; }

        .btn {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 0.6rem 1.2rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.2s;
            width: 100%;
            margin-top: auto;
        }
        .btn:hover { background-color: var(--accent-hover); }
        .btn:disabled { background-color: #555; cursor: not-allowed; }

        .debug-info {
            font-family: monospace;
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-top: 1rem;
            background: rgba(0,0,0,0.2);
            padding: 0.5rem;
            border-radius: 4px;
        }

        /* è¯Šæ–­ç»“æœ (å³ä¸‹) */
        .diagnosis-card {
            grid-column: 2 / 3;
            grid-row: 2 / 3;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        .diagnosis-result { font-size: 2rem; font-weight: bold; color: var(--accent-color); margin-bottom: 0.5rem; }
        .diagnosis-conf { font-size: 1.1rem; color: var(--text-secondary); }

        /* Loading Overlay */
        #loading-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 1000;
            display: none;
        }
        .spinner {
            width: 50px; height: 50px;
            border: 5px solid var(--text-secondary);
            border-top: 5px solid var(--accent-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 1rem;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* å¸ƒå±€çŠ¶æ€åˆ‡æ¢ */
        .layout-initial .upload-container {
            max-width: 600px;
            margin: 4rem auto;
        }
        
        .layout-analyzed .upload-container {
            display: none; /* åˆ†æåéšè—å¤§çš„ä¸Šä¼ æ¡†ï¼Œå¯ä»¥é€šè¿‡é¡µé¢åº•éƒ¨çš„æŒ‰é’®é‡æ–°ä¸Šä¼  */
        }
        
        .layout-analyzed .results-grid {
            display: grid;
        }

        .reupload-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            display: none;
        }
    </style>
</head>
<body class="layout-initial">

<div id="loading-overlay">
    <div class="spinner"></div>
    <div id="loading-text">åŠ è½½æ¨¡å‹ä¸­...</div>
</div>

<header>
    <h1>OCT è§†ç½‘è†œæ™ºèƒ½è¯Šæ–­</h1>
    <div class="status" id="model-status">æ­£åœ¨åˆå§‹åŒ–...</div>
</header>

<main>
    <!-- ä¸Šä¼ åŒº -->
    <div class="upload-container" id="drop-zone">
        <div class="upload-icon">ğŸ“</div>
        <div class="upload-text">ç‚¹å‡»æˆ–æ‹–æ‹½ OCT å›¾åƒåˆ°æ­¤å¤„</div>
        <div class="upload-subtext">æ”¯æŒ PNG, JPG, JPEG</div>
        <input type="file" id="file-input" accept="image/*">
    </div>

    <!-- ç»“æœå±•ç¤ºåŒº -->
    <div class="results-grid">
        <!-- å›¾åƒä¸çƒ­åŠ›å›¾ -->
        <div class="card image-view-card">
            <h2>åŸå§‹å›¾åƒä¸çƒ­åŠ›å›¾</h2>
            <div class="image-wrapper">
                <img id="preview-image" alt="Preview">
                <canvas id="heatmap-canvas"></canvas>
            </div>
        </div>

        <!-- çƒ­åŠ›å›¾æ§åˆ¶ -->
        <div class="card heatmap-controls-card">
            <h2>å¯è§£é‡Šæ€§åˆ†æ (Occlusion Sensitivity)</h2>
            <div style="flex: 1;">
                <p style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 1rem;">
                    çº¢è‰²åŒºåŸŸè¡¨ç¤ºå¯¹æ¨¡å‹åˆ¤æ–­ä¸ºå½“å‰ç±»åˆ«æœ€å…³é”®çš„åŒºåŸŸï¼ˆé®æŒ¡åç½®ä¿¡åº¦ä¸‹é™æœ€å¤§ï¼‰ã€‚
                </p>
                
                <div class="heatmap-legend-container">
                    <div class="heatmap-legend-gradient"></div>
                    <div class="heatmap-legend-labels">
                        <span>é«˜é‡è¦æ€§</span>
                        <span>ä¸­é‡è¦æ€§</span>
                        <span>ä½é‡è¦æ€§</span>
                    </div>
                    <div style="flex:1; margin-left: 1rem;">
                         <div class="debug-info" id="heatmap-debug">
                            ç­‰å¾…ç”Ÿæˆ...
                        </div>
                    </div>
                </div>

                <div class="control-group">
                    <label>é®æŒ¡å—å¤§å° (Patch Size) <span class="control-value" id="val-patch">16</span></label>
                    <input type="range" id="param-patch" min="8" max="48" step="4" value="16">
                </div>
                <div class="control-group">
                    <label>æ‰«ææ­¥é•¿ (Stride) <span class="control-value" id="val-stride">8</span></label>
                    <input type="range" id="param-stride" min="4" max="24" step="4" value="8">
                </div>
                <div class="control-group">
                    <label>çƒ­åŠ›å›¾é€æ˜åº¦ <span class="control-value" id="val-opacity">0.6</span></label>
                    <input type="range" id="param-opacity" min="0" max="1" step="0.1" value="0.6">
                </div>
            </div>
            <button class="btn" id="btn-analyze" disabled>ç”Ÿæˆ/æ›´æ–°çƒ­åŠ›å›¾</button>
        </div>

        <!-- æ¦‚ç‡åˆ†å¸ƒ -->
        <div class="card prob-card">
            <h2>é¢„æµ‹æ¦‚ç‡åˆ†å¸ƒ</h2>
            <div id="prob-bars">
                <!-- åŠ¨æ€ç”Ÿæˆ -->
            </div>
        </div>

        <!-- è¯Šæ–­ç»“è®º -->
        <div class="card diagnosis-card">
            <h2>AI è¯Šæ–­å»ºè®®</h2>
            <div class="diagnosis-result" id="final-result">--</div>
            <div class="diagnosis-conf" id="final-conf">ç½®ä¿¡åº¦: --%</div>
        </div>
    </div>
</main>

<button class="reupload-btn" id="btn-reupload">ä¸Šä¼ æ–°å›¾ç‰‡</button>

<script>
    // é…ç½®
    const CONFIG = {
        modelUrl: './model.json',
        labels: ['DME', 'DRUSEN', 'NORMAL', 'CNV'], // å¯¹åº” dict.txt: 1-DME, 2-DRUSEN, 3-NORMAL, 4-CNV
        inputSize: 224
    };

    // å…¨å±€çŠ¶æ€
    let model = null;
    let currentImageElement = null; // HTMLImageElement
    let currentTensor = null;       // é¢„å¤„ç†åçš„ tensor [1, 224, 224, 3]
    let currentPrediction = null;   // { index, label, confidence, allProbs }
    let isAnalyzing = false;

    // DOM å…ƒç´ 
    const els = {
        dropZone: document.getElementById('drop-zone'),
        fileInput: document.getElementById('file-input'),
        previewImg: document.getElementById('preview-image'),
        heatmapCanvas: document.getElementById('heatmap-canvas'),
        status: document.getElementById('model-status'),
        body: document.body,
        loadingOverlay: document.getElementById('loading-overlay'),
        loadingText: document.getElementById('loading-text'),
        probBars: document.getElementById('prob-bars'),
        finalResult: document.getElementById('final-result'),
        finalConf: document.getElementById('final-conf'),
        btnAnalyze: document.getElementById('btn-analyze'),
        btnReupload: document.getElementById('btn-reupload'),
        heatmapDebug: document.getElementById('heatmap-debug'),
        params: {
            patch: document.getElementById('param-patch'),
            stride: document.getElementById('param-stride'),
            opacity: document.getElementById('param-opacity')
        },
        vals: {
            patch: document.getElementById('val-patch'),
            stride: document.getElementById('val-stride'),
            opacity: document.getElementById('val-opacity')
        }
    };

    // --- åˆå§‹åŒ– ---

    async function init() {
        showLoading('åŠ è½½æ¨¡å‹ä¸­...');
        try {
            // åŠ è½½æ¨¡å‹
            model = await tf.loadGraphModel(CONFIG.modelUrl);
            
            // é¢„çƒ­æ¨¡å‹ (Warmup)
            const zeros = tf.zeros([1, CONFIG.inputSize, CONFIG.inputSize, 3]);
            model.predict(zeros).dispose();
            zeros.dispose();

            els.status.textContent = 'æ¨¡å‹å°±ç»ª';
            els.status.classList.add('ready');
            hideLoading();
            console.log('Model loaded');
        } catch (error) {
            console.error(error);
            els.status.textContent = 'æ¨¡å‹åŠ è½½å¤±è´¥: ' + error.message;
            els.status.style.color = 'var(--danger-color)';
            hideLoading();
            alert('æ— æ³•åŠ è½½æ¨¡å‹ model.jsonï¼Œè¯·ç¡®ä¿æ–‡ä»¶ä½äºå½“å‰ç›®å½•ã€‚');
        }

        setupEventListeners();
    }

    function setupEventListeners() {
        // æ–‡ä»¶ä¸Šä¼ äº¤äº’
        els.dropZone.addEventListener('click', () => els.fileInput.click());
        els.fileInput.addEventListener('change', (e) => handleFiles(e.target.files));
        
        els.dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            els.dropZone.classList.add('drag-over');
        });
        els.dropZone.addEventListener('dragleave', () => els.dropZone.classList.remove('drag-over'));
        els.dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            els.dropZone.classList.remove('drag-over');
            handleFiles(e.dataTransfer.files);
        });

        // é‡æ–°ä¸Šä¼ 
        els.btnReupload.addEventListener('click', () => {
            els.body.classList.remove('layout-analyzed');
            els.body.classList.add('layout-initial');
            els.btnReupload.style.display = 'none';
            els.fileInput.value = '';
            // æ¸…ç†
            clearResults();
        });

        // çƒ­åŠ›å›¾å‚æ•°æ§åˆ¶
        Object.keys(els.params).forEach(key => {
            els.params[key].addEventListener('input', (e) => {
                els.vals[key].textContent = e.target.value;
            });
        });
        
        // ä»…ä¿®æ”¹é€æ˜åº¦æ—¶ä¸éœ€è¦é‡æ–°è®¡ç®—ï¼Œåªéœ€è¦é‡ç»˜
        els.params.opacity.addEventListener('change', () => {
            if (window.lastHeatmapData) drawHeatmap(window.lastHeatmapData);
        });

        els.btnAnalyze.addEventListener('click', () => {
            if (isAnalyzing) return;
            generateOcclusionHeatmap();
        });
    }

    // --- æ ¸å¿ƒé€»è¾‘ ---

    function handleFiles(files) {
        if (files.length === 0) return;
        const file = files[0];
        if (!file.type.startsWith('image/')) {
            alert('è¯·ä¸Šä¼ å›¾ç‰‡æ–‡ä»¶');
            return;
        }
        // --- å°±åŠ åœ¨è¿™é‡Œ ---
        uploadToBackend(file); 
        // ------------------
        const reader = new FileReader();
        reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
                currentImageElement = img;
                runPredictionPipeline();
            };
            img.src = e.target.result;
            els.previewImg.src = e.target.result;
        };
        reader.readAsDataURL(file);
    }

    async function runPredictionPipeline() {
        if (!model) return;
        
        // UI åˆ‡æ¢
        els.body.classList.remove('layout-initial');
        els.body.classList.add('layout-analyzed');
        els.btnReupload.style.display = 'block';
        showLoading('æ­£åœ¨è¯Šæ–­...');
        clearResults();

        // 1. é¢„å¤„ç†
        const tensor = tf.tidy(() => {
            return tf.browser.fromPixels(currentImageElement)
                .resizeNearestNeighbor([CONFIG.inputSize, CONFIG.inputSize])
                .toFloat()
                .div(tf.scalar(255))
                .expandDims();
        });
        currentTensor = tensor; // ä¿å­˜å¼•ç”¨ç”¨äºçƒ­åŠ›å›¾åˆ†æ

        // 2. æ¨ç†
        const startTime = performance.now();
        const predictions = await model.predict(tensor).data();
        const endTime = performance.now();
        console.log(`Inference time: ${(endTime - startTime).toFixed(2)}ms`);

        // 3. è§£æç»“æœ
        const result = Array.from(predictions).map((prob, i) => ({
            prob: prob,
            label: CONFIG.labels[i],
            index: i
        })).sort((a, b) => b.prob - a.prob);

        currentPrediction = result[0];
        
        // 4. æ›´æ–° UI
        updateResultsUI(result);
        
        // 5. è‡ªåŠ¨ç”Ÿæˆä¸€æ¬¡é»˜è®¤å‚æ•°çš„çƒ­åŠ›å›¾ (ç¨ä½œå»¶è¿Ÿä»¥å…ˆæ˜¾ç¤ºç»“æœ)
        hideLoading();
        setTimeout(() => {
            generateOcclusionHeatmap();
        }, 500);
    }

    function updateResultsUI(sortedResults) {
        // æ¦‚ç‡æ¡å½¢å›¾
        els.probBars.innerHTML = '';
        sortedResults.forEach(item => {
            const div = document.createElement('div');
            div.className = 'prob-bar-container';
            const percentage = (item.prob * 100).toFixed(1) + '%';
            div.innerHTML = `
                <div class="prob-label">
                    <span>${item.label}</span>
                    <span>${percentage}</span>
                </div>
                <div class="prob-bar-bg">
                    <div class="prob-bar-fill" style="width: ${percentage}"></div>
                </div>
            `;
            els.probBars.appendChild(div);
        });

        // æœ€ç»ˆè¯Šæ–­
        const best = sortedResults[0];
        els.finalResult.textContent = best.label;
        els.finalConf.textContent = `ç½®ä¿¡åº¦: ${(best.prob * 100).toFixed(2)}%`;
        
        // å¦‚æœç½®ä¿¡åº¦ä½ï¼Œæ ‡è®°é¢œè‰²
        if (best.prob < 0.6) {
            els.finalResult.style.color = 'var(--warning-color)';
        } else {
            els.finalResult.style.color = 'var(--accent-color)';
        }

        // å¯ç”¨åˆ†ææŒ‰é’®
        els.btnAnalyze.disabled = false;
    }

    function clearResults() {
        const ctx = els.heatmapCanvas.getContext('2d');
        ctx.clearRect(0, 0, els.heatmapCanvas.width, els.heatmapCanvas.height);
        window.lastHeatmapData = null;
        if (currentTensor) {
            // æ³¨æ„ï¼šè¿™é‡Œæˆ‘ä»¬ä¸dispose currentTensorï¼Œå› ä¸ºçƒ­åŠ›å›¾åˆ†æè¿˜éœ€è¦å®ƒ
            // åªæœ‰åœ¨åŠ è½½æ–°å›¾æ—¶æ‰å½»åº•æ›¿æ¢
        }
    }

    // --- Occlusion Sensitivity ç®—æ³• ---

    async function generateOcclusionHeatmap() {
        if (!model || !currentTensor || !currentPrediction) return;

        isAnalyzing = true;
        els.btnAnalyze.disabled = true;
        els.btnAnalyze.textContent = 'ç”Ÿæˆä¸­...';
        els.heatmapDebug.textContent = 'è®¡ç®—ä¸­...';
        
        // è·å–å‚æ•°
        const patchSize = parseInt(els.params.patch.value);
        const stride = parseInt(els.params.stride.value);
        const targetClassIndex = currentPrediction.index;
        const baselineConf = currentPrediction.prob;

        // å¼‚æ­¥æ‰§è¡Œä»¥ä¸é˜»å¡ UI
        setTimeout(async () => {
            try {
                // 1. å‡†å¤‡æ•°æ®
                const width = CONFIG.inputSize;
                const height = CONFIG.inputSize;
                const heatmapW = Math.floor((width - patchSize) / stride) + 1;
                const heatmapH = Math.floor((height - patchSize) / stride) + 1;
                
                // å­˜å‚¨æ¯ä¸ªä½ç½®çš„ç½®ä¿¡åº¦ä¸‹é™å€¼
                const sensitivityMap = new Float32Array(heatmapW * heatmapH);
                
                // è·å–å›¾åƒåŸå§‹æ•°æ®ç”¨äºé®æŒ¡æ“ä½œ
                // currentTensor æ˜¯ GPU tensor, ä¸‹è½½åˆ° CPU
                const originalData = await currentTensor.squeeze().array(); // [224, 224, 3]

                let maxDrop = 0;
                let minDrop = 0;
                let totalDrop = 0;

                // 2. å¾ªç¯éå†å›¾åƒ
                // ä¼˜åŒ–ï¼šæˆ‘ä»¬å¯ä»¥æ„å»ºä¸€ä¸ª batch ä¸€æ¬¡é¢„æµ‹å¤šä¸ªï¼Œä½†ä¸ºäº†ä»£ç ç®€å•å’Œæ˜¾å­˜å®‰å…¨ï¼Œè¿™é‡Œé€ä¸ªæˆ–å°æ‰¹é‡é¢„æµ‹
                // è€ƒè™‘åˆ°æµè§ˆå™¨ç¯å¢ƒï¼Œæˆ‘ä»¬é€ä¸ªé¢„æµ‹ï¼Œä½†ä¸ºäº†é€Ÿåº¦ï¼Œæ¯è¡Œä½œä¸ºä¸€ä¸ª batchï¼Ÿ
                // ç®€å•èµ·è§ï¼Œé€ä¸ªé¢„æµ‹ï¼Œä½†ç”¨ tf.tidy åŠæ—¶æ¸…ç†
                
                let count = 0;
                for (let y = 0; y < heatmapH; y++) {
                    for (let x = 0; x < heatmapW; x++) {
                        const startX = x * stride;
                        const startY = y * stride;
                        
                        // åˆ›å»ºé®æŒ¡åçš„å›¾åƒå¼ é‡
                        const conf = tf.tidy(() => {
                            // å¤åˆ¶ä¸€ä»½æ•°æ® (è¿™æ˜¯æ¯”è¾ƒè€—æ—¶çš„ï¼Œä½†åœ¨ JS ä¸­ä¿®æ”¹ Array æ¯”æ“ä½œ Tensor å®¹æ˜“ç†è§£)
                            // æ›´å¿«çš„æ–¹æ³•æ˜¯ä½¿ç”¨ tf.buffer æˆ– maskï¼Œä½†è¿™é‡Œä¸ºäº†é€»è¾‘æ¸…æ™°ä½¿ç”¨ buffer
                            const buffer = tf.buffer([1, height, width, 3]);
                            
                            // è¿™ä¸€æ­¥æ‹·è´éå¸¸æ…¢ï¼Œä¼˜åŒ–ç­–ç•¥ï¼šåªåœ¨ GPU ä¸Šæ“ä½œ
                            // æ›´å¥½çš„ GPU æ“ä½œï¼šåˆ›å»ºä¸€ä¸ª mask tensorï¼Œç„¶å image * mask + gray * (1-mask)
                            // è®©æˆ‘ä»¬å°è¯• GPU æ–¹æ³•
                            
                            // åˆ›å»º mask: å…¨ 1
                            const maskBuffer = tf.buffer([height, width, 3]);
                            for(let i=0; i<height; i++) {
                                for(let j=0; j<width; j++) {
                                    // é»˜è®¤ä¿ç•™åŸå›¾
                                    maskBuffer.set(1, i, j, 0);
                                    maskBuffer.set(1, i, j, 1);
                                    maskBuffer.set(1, i, j, 2);
                                }
                            }
                            
                            // å°†é®æŒ¡åŒºåŸŸè®¾ä¸º 0
                            for(let i=startY; i<startY+patchSize; i++) {
                                for(let j=startX; j<startX+patchSize; j++) {
                                    if(i<height && j<width) {
                                        maskBuffer.set(0, i, j, 0);
                                        maskBuffer.set(0, i, j, 1);
                                        maskBuffer.set(0, i, j, 2);
                                    }
                                }
                            }
                            const mask = maskBuffer.toTensor().expandDims(0); // [1, 224, 224, 3]
                            
                            // é®æŒ¡å›¾åƒ = åŸå›¾ * mask + ç°è‰²(0.5) * (1-mask)
                            const gray = tf.scalar(0.5);
                            const maskedImage = currentTensor.mul(mask).add(gray.mul(tf.scalar(1).sub(mask)));
                            
                            const pred = model.predict(maskedImage);
                            const res = pred.dataSync(); // åŒæ­¥è·å–ç»“æœ
                            return res[targetClassIndex];
                        });

                        // è®¡ç®—æ•æ„Ÿåº¦ï¼šåŸºå‡† - é®æŒ¡å
                        // å¦‚æœé®æŒ¡åç½®ä¿¡åº¦å¤§å¹…ä¸‹é™ (å€¼å˜å°)ï¼Œdiff ä¸ºæ­£å¤§å€¼ -> é‡è¦åŒºåŸŸ
                        const diff = baselineConf - conf;
                        sensitivityMap[y * heatmapW + x] = diff;
                        
                        if (diff > maxDrop) maxDrop = diff;
                        if (diff < minDrop) minDrop = diff;
                        totalDrop += diff;
                        
                        count++;
                    }
                    // æ¯å¤„ç†å®Œä¸€è¡Œï¼Œè®©å‡ºä¸»çº¿ç¨‹ä¸€ä¼šï¼Œæ›´æ–°è¿›åº¦
                    if (y % 2 === 0) await new Promise(r => setTimeout(r, 0));
                }

                const avgDrop = totalDrop / count;

                // 3. å¤„ç†çƒ­åŠ›å›¾æ•°æ®
                // å½’ä¸€åŒ–åˆ° 0-1 (åªå…³æ³¨æ­£å‘è´¡çŒ®ï¼Œå³ diff > 0 çš„éƒ¨åˆ†)
                // æˆ‘ä»¬ä¸»è¦å…³å¿ƒæ­£å€¼ï¼ˆç½®ä¿¡åº¦ä¸‹é™ï¼‰ï¼Œè´Ÿå€¼æ„å‘³ç€é®æŒ¡åç½®ä¿¡åº¦åè€Œä¸Šå‡ï¼ˆè¯´æ˜è¯¥åŒºåŸŸæ˜¯å¹²æ‰°é¡¹ï¼‰ï¼Œæš‚æ—¶å¿½ç•¥æˆ–è®¾ä¸º0
                const normalizedMap = new Float32Array(sensitivityMap.length);
                for (let i = 0; i < sensitivityMap.length; i++) {
                    // ReLU: åªçœ‹æ­£å€¼
                    let val = Math.max(0, sensitivityMap[i]);
                    // å½’ä¸€åŒ–
                    if (maxDrop > 0) {
                        normalizedMap[i] = val / maxDrop;
                    } else {
                        normalizedMap[i] = 0;
                    }
                }

                // ä¿å­˜æ•°æ®ä»¥ä¾¿è°ƒæ•´é€æ˜åº¦æ—¶é‡ç»˜
                const heatmapData = {
                    map: normalizedMap,
                    w: heatmapW,
                    h: heatmapH,
                    maxDrop,
                    avgDrop,
                    baselineConf
                };
                window.lastHeatmapData = heatmapData;

                drawHeatmap(heatmapData);

                // æ›´æ–°è°ƒè¯•ä¿¡æ¯
                els.heatmapDebug.innerHTML = `
                    åŸºå‡†ç½®ä¿¡åº¦: ${(baselineConf*100).toFixed(1)}%<br>
                    æœ€å¤§ä¸‹é™: ${(maxDrop*100).toFixed(1)}%<br>
                    å¹³å‡ä¸‹é™: ${(avgDrop*100).toFixed(2)}%
                `;

            } catch (err) {
                console.error('Heatmap generation failed', err);
                els.heatmapDebug.textContent = 'ç”Ÿæˆå¤±è´¥';
            } finally {
                isAnalyzing = false;
                els.btnAnalyze.disabled = false;
                els.btnAnalyze.textContent = 'ç”Ÿæˆ/æ›´æ–°çƒ­åŠ›å›¾';
            }
        }, 50); // initial delay
    }

    function drawHeatmap(data) {
        const canvas = els.heatmapCanvas;
        const ctx = canvas.getContext('2d');
        const img = els.previewImg;
        
        // åŒ¹é…æ˜¾ç¤ºå°ºå¯¸
        canvas.width = img.clientWidth;
        canvas.height = img.clientHeight;

        // æ¸…ç©º
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // åˆ›å»ºç¦»å± canvas ç»˜åˆ¶å°çƒ­åŠ›å›¾
        const offCanvas = document.createElement('canvas');
        offCanvas.width = data.w;
        offCanvas.height = data.h;
        const offCtx = offCanvas.getContext('2d');
        
        // ç»˜åˆ¶åƒç´ 
        const imgData = offCtx.createImageData(data.w, data.h);
        const pixels = imgData.data;
        const opacity = parseFloat(els.params.opacity.value);

        for (let i = 0; i < data.map.length; i++) {
            const val = data.map[i]; // 0-1
            // ç®€å•çš„çƒ­åŠ›å›¾é¢œè‰²æ˜ å°„ï¼šé€æ˜ -> çº¢
            // å€¼è¶Šå¤§è¶Šçº¢
            // R: 255, G: 255 * (1-val), B: 0
            // å®é™…ä¸Šä¸ºäº†å¥½çœ‹ï¼Œå¯ä»¥ä½¿ç”¨ Jet æˆ– Turbo ä¼ªå½©è‰²ï¼Œè¿™é‡Œç®€åŒ–ä¸ºçº¢è‰²é€æ˜åº¦
            
            // ç­–ç•¥ï¼šé«˜é‡è¦æ€§ä¸ºçº¢è‰²ï¼Œä½é‡è¦æ€§é€æ˜
            // æˆ‘ä»¬å¯ä»¥ç”¨ç±»ä¼¼ HSV è½¬ RGB çš„æ–¹å¼ï¼Œæˆ–è€…ç®€å•çš„ Red gradient
            
            // çº¢è‰²é€šé“æ»¡ï¼Œç»¿è‰²é€šé“éšå€¼å‡å° (1->é»„è‰², 0->çº¢è‰²) - è¿™ç§æ›´å¥½çœ‹
            // ä½†æ ‡å‡†çƒ­åŠ›å›¾é€šå¸¸æ˜¯: ä½->è“/é€æ˜, ä¸­->é»„, é«˜->çº¢
            // è¿™é‡Œæˆ‘ä»¬ç”¨: 0->é€æ˜, 0.5->é»„, 1.0->çº¢
            
            let r, g, b, a;
            
            if (val < 0.1) {
                // å¿½ç•¥ä½å½±å“åŒºåŸŸ
                r=0; g=0; b=0; a=0;
            } else {
                r = 255;
                g = Math.floor(255 * (1 - val)); // val=1 -> g=0 (çº¢), val=0 -> g=255 (é»„/ç™½)
                b = 0;
                a = Math.floor(255 * opacity * Math.min(1, val * 1.5)); // å¢å¼ºä¸€ç‚¹å¯è§æ€§
            }

            const pIndex = i * 4;
            pixels[pIndex] = r;
            pixels[pIndex + 1] = g;
            pixels[pIndex + 2] = b;
            pixels[pIndex + 3] = a;
        }
        
        offCtx.putImageData(imgData, 0, 0);

        // å°†å°çƒ­åŠ›å›¾æ‹‰ä¼¸ç»˜åˆ¶åˆ°å¤§ Canvas (è‡ªåŠ¨åŒçº¿æ€§æ’å€¼å®ç°å¹³æ»‘)
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        ctx.drawImage(offCanvas, 0, 0, canvas.width, canvas.height);
    }

    // --- Helper ---

    function showLoading(text) {
        els.loadingText.textContent = text;
        els.loadingOverlay.style.display = 'flex';
    }

    function hideLoading() {
        els.loadingOverlay.style.display = 'none';
    }

    // å¯åŠ¨
    // --- è¿æ¥åç«¯çš„é€»è¾‘ ---
    async function uploadToBackend(imageFile) {
        let formData = new FormData();
        formData.append("image", imageFile);

        try {
            console.log("æ­£åœ¨å°è¯•åŒæ­¥åˆ°åç«¯...");
            let response = await fetch("http://localhost:5000/predict", {
                method: "POST",
                body: formData
            });
            let data = await response.json();
            console.log("åç«¯åé¦ˆ:", data);
        } catch (error) {
            console.error("åç«¯è¿æ¥å¤±è´¥:", error);
        }
    }
    init();

</script>
</body>
</html>